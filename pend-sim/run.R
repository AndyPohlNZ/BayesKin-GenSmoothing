# # -------------------- Simple Pendulum Example --------------------------
# This example simulates observed marker positions from a simple pendulum
# model and implementes either a time independent, generalised smoothing
# or the true ODE model to generate solutions to the IK problem

# Written as part of:
#      Pohl, Schofield and Ferber. (2022).
#      A generalised smoothing approach for continuous, planar, inverse kinematics problems
#
#       Code by: Andy Pohl
#       Human Perforamnce Labortory
#       Faculty of Kinesiology
#       University of Calgary
#       December 2021

## library.R Contains functions used within the main analysis.
## run.R Fits models to 100 sets of observed marker positions simulated from the
#       pendulum model.
## analysis.R Generates results and plots found within the manuscript.

## ./model-files/
##     sim-pendulum.stan contains stan code to simulate the pendulum system
##          given initial conditions
##     obs-pendulum.stan contains stan code to simulate observed markers in the
#           presence of measurement nosie sigma.

## ./model-fits/
##     contains R data files of each model fit to each simulation.
##
## ./figures/
##     contains figures generated by analysis.R and referenced in the manuscript
# --------------------- Perliminaries -------------------------------------
# Source statements
source("./library.R")

# Number of simualtions to run
nSim <<- 100
seeds <<- 1:nSim # Generate seeds for each simulation

# ------------------------ Global Constants -------------------------------
grav <<- 9.80665 # Gravitational acceleration

# -------------------- Define True Values for simulation --------------------
# Link parms
nM <<- 4 # number of markers
nD <<- 2 # number of dimensions

# pendulum parameters
lm_true <<- 1 # Length of pendulum in meters
parms <- list(g = grav, Lm = lm_true)


# Initial conditions
r0_true <- c(0, 0) # Base point position in GCS
theta0_true <- -20 * pi / 180 # initial angle
dtheta0_true <- 0 # initial angular velocity.
state0_true <- c(theta0_true, dtheta0_true)

period <- 2 * pi * sqrt(lm_true / grav)
# Time related parameters
samp_freq <- 200
start_time <- 0
end_time <- period
ts <- seq(start_time, end_time, length.out = end_time * samp_freq)
nT <- length(ts)

# Total number of observations
N <<- nM * nT

# Measurement noise
sigma_true <- 50 / 1000 # 50mm of noise

# ---------------------- Get true state over time ------------------------
states_true <- sim_pend(ts, c(theta0_true, dtheta0_true),
    parms = parms
)

r_true <- matrix(NA, nrow = nT, ncol = nD)
for (t in 1:nT) {
    r_true[t, ] <- r0_true
}

# ---------------------- Gen static trial --------------------------------------
x <- gen_link(seg_length = lm_true, plate_placement = 0.7)

# ---------------------- Save True Values -------------------------------------
true_vals <- list(
    r0_true = r0_true,
    theta0_true = theta0_true,
    dtheta0_true = dtheta0_true,
    state0_true = state0_true,
    r_true = r_true,
    states_true = states_true,
    sigma_true = sigma_true,
    period_true = period,
    parms_true = parms,
    x = x,
    N = N,
    nM = nM,
    nT = nT,
    ts = ts,
    seeds = seeds
)

saveRDS(true_vals, "./true_vals.rds")


# ---------------------- Set up spline basis --------------------------------------
nK <<- 30 # Number of basis terms
fbasis <<- fourier_basis(ts, nK, period = range(ts)[2])
dfbasis <<- fourier_basis(ts, nK, period = range(ts)[2], derative = 1)

# ---------------------- Run simulations --------------------------------------
for (i in 1:nSim) {
    # Set seed for simulation
    seed <<- seeds[i]
    set.seed(seed)

    print(sprintf("Running iteration %.0f of %.0f", i, nSim))

    # Generate a set of observations y
    print("Generating observation")
    obs <- gen_obs(ts, state0_true, x, r_true, sigma_true, parms)
    y <- obs$y # Observed marker positions.
    alpha <- obs$alpha # True marker positions.
    print("Complete")
    # Prep data in list format
    dat <- list()
    dat$y <- matrix(NA, nrow = N, ncol = 2)
    dat$ts <-
        dat$midx <- dat$tidx <- rep(NA, N) # initilise fields
    idx <- 1
    for (t in 1:nT) {
        for (m in 1:nM) {
            dat$y[idx, 1:nD] <- y[m, 1:nD, t]
            dat$ts[idx] <- ts[t]
            dat$midx[idx] <- m
            dat$tidx[idx] <- t
            idx <- idx + 1
        }
    }

    model_data <- list(
        N = N,
        nM = nM,
        nD = nD,
        nT = nT,
        ts = ts,
        midx = dat$midx,
        tidx = dat$tidx,
        y = dat$y,
        x = t(x)
    )

    # Generate LS solution to be used as initial values.
    print("    Generating LS solution for inital values")
    ls_inits <<- gen_LS_inits(y = y, x = x, Lm = lm_true)

    # Fit model 1 - Time independent model
    print("    Fitting Model 1")
    mod1_fit <- mod1$sample(
        data = model_data,
        init = mod1_inits, # using Stan inits for now
        chains = n_chains,
        iter_warmup = n_warmup,
        iter_sampling = n_iter,
        seed = seed,
        save_warmup = TRUE,
        parallel_chains = 4
    )
    print("        - saving model 1 output")
    mod1_fit$save_object(
        file = sprintf("./model-fits/mod1_fit_%0.0f.rds", seed)
    )
    print("    Model 1 Complete")

    # Fit model 2 - Generalised smoothing model
    print("    Fitting Model 2")
    mod2_fit <- mod2$sample(
        data = append(model_data, list(
            nK = nK,
            nK2 = nK / 2,
            fBasis = fbasis,
            dfBasis = dfbasis
        )),
        init = mod2_inits, # using Stan inits for now
        chains = n_chains,
        iter_warmup = n_warmup,
        iter_sampling = n_iter,
        seed = seed,
        save_warmup = TRUE,
        parallel_chains = 4
    )
    print("        - saving model 2 output")
    mod2_fit$save_object(
        file = sprintf("./model-fits/mod2_fit_%0.0f.rds", seed)
    )
    print("    Model 2 Complete")

    # Fit model 3 - ODE model
    print("    Fitting Model 3")
    mod3_fit <- mod3$sample(
        data = model_data,
        init = mod3_inits, # using Stan inits for now
        chains = n_chains,
        iter_warmup = n_warmup,
        iter_sampling = n_iter,
        seed = seed,
        save_warmup = TRUE,
        parallel_chains = 4
    )
    print("        - saving model 3 output")
    mod3_fit$save_object(
        file = sprintf("./model-fits/mod3_fit_%0.0f.rds", seed)
    )
    print("    Model 3 Complete")
}